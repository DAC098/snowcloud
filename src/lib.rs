use std::{
    sync::{
        Arc,
        Mutex,
    },
    time::{
        Instant,
        SystemTime,
        Duration,
    },
};

pub mod traits;
pub mod error;

/// generates Snowcloud and Snowflake for the given bit sizes
///
/// on the chance that the bit sizes are not what you want you can generate
/// your own with different sizes without having to modify the library
#[macro_export]
macro_rules! gen_code {
    ($ts_bits:expr, $mid_bits:expr, $seq_bits:expr) => {
        pub const TIMESTAMP_BITS: i64 = $ts_bits;
        pub const MACHINE_ID_BITS: i64 = $mid_bits;
        pub const SEQUENCE_BITS: i64 = $seq_bits;

        pub const MAX_TIMESTAMP: i64 = (1 << TIMESTAMP_BITS) - 1;
        pub const MAX_MACHINE_ID: i64 = (1 << MACHINE_ID_BITS) - 1;
        pub const MAX_SEQUENCE: i64 = (1 << SEQUENCE_BITS) - 1;

        pub const TIMESTAMP_SHIFT: i64 = MACHINE_ID_BITS + SEQUENCE_BITS;
        pub const MACHINE_ID_SHIFT: i64 = SEQUENCE_BITS;

        pub const TIMESTAMP_MASK: i64 = MAX_TIMESTAMP << TIMESTAMP_SHIFT;
        pub const MACHINE_ID_MASK: i64 = MAX_MACHINE_ID << MACHINE_ID_SHIFT;
        pub const SEQUENCE_MASK: i64 = MAX_SEQUENCE;

        pub const MAX_DURATION: Duration = Duration::from_millis((1 << TIMESTAMP_BITS) - 1);

        /// id generated from a Snowcloud
        ///
        /// since ts is a duration, it will only have full accuracy when
        /// generated by a Snowcloud. if its created from an i64 or from_parts
        /// accuracy will be lost since the timestamp will only be milliseconds
        /// vs nanoseconds
        #[derive(Eq, Hash, PartialEq, Clone)]
        pub struct Snowflake {
            ts: Duration,
            mid: i64,
            seq: i64,
        }

        impl Snowflake {
            /// returns ts
            pub fn duration(&self) -> &Duration {
                &self.ts
            }

            /// returns timestamp as millis from stored ts
            pub fn timestamp(&self) -> i64 {
                self.ts.as_millis() as i64
            }

            /// returns machine id reference
            pub fn machine_id(&self) -> &i64 {
                &self.mid
            }

            /// returns sequence reference
            pub fn sequence(&self) -> &i64 {
                &self.seq
            }

            /// generates a Snowflake from the provided parts
            ///
            /// checks will be performed on each part to ensure that they are
            /// valid for the given Snowflake
            pub fn from_parts(ts: i64, mid: i64, seq: i64) -> error::Result<Snowflake> {
                if ts < 0 || ts > MAX_TIMESTAMP {
                    return Err(error::Error::EpochInvalid);
                }

                if mid < 0 || mid > MAX_MACHINE_ID {
                    return Err(error::Error::MachineIdInvalid);
                }

                if seq < 0 || seq > MAX_SEQUENCE {
                    return Err(error::Error::SequenceInvalid);
                }

                let ts = Duration::from_millis(ts as u64);

                Ok(Snowflake { ts, mid, seq })
            }

            /// splits the current Snowflake into its individual parts
            pub fn into_parts(self) -> (i64, i64, i64) {
                let millis = self.ts.as_millis() as i64;

                (millis, self.mid, self.seq)
            }

            /// generates the unique id
            pub fn id(&self) -> i64 {
                let millis = self.ts.as_millis() as i64;

                (millis << TIMESTAMP_SHIFT) | (self.mid << MACHINE_ID_SHIFT) | self.seq
            }
        }

        impl std::fmt::Debug for Snowflake {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let id = self.id();
                let millis = self.ts.as_millis();

                f.debug_struct("Snowflake")
                    .field("id", &id)
                    .field("millis", &millis)
                    .field("ts", &self.ts)
                    .field("mid", &self.mid)
                    .field("seq", &self.seq)
                    .finish()
            }
        }

        impl From<Snowflake> for i64 {
            fn from(flake: Snowflake) -> i64 {
                flake.id()
            }
        }

        impl From<&Snowflake> for i64 {
            fn from(flake: &Snowflake) -> i64 {
                flake.id()
            }
        }

        impl TryFrom<i64> for Snowflake {
            type Error = error::Error;

            fn try_from(id: i64) -> error::Result<Snowflake> {
                if id < 0 {
                    return Err(error::Error::InvalidId);
                }

                let millis = ((id & TIMESTAMP_MASK) >> TIMESTAMP_SHIFT) as u64;

                Ok(Snowflake {
                    ts: Duration::from_millis(millis),
                    mid: (id & MACHINE_ID_MASK) >> MACHINE_ID_SHIFT,
                    seq: id & SEQUENCE_MASK
                })
            }
        }

        /// stores sequence and prev_time for a Snowcloud
        ///
        /// is guarded by an Arc Mutex since this data is shared between
        /// threads
        struct Counts {
            sequence: i64,
            prev_time: Duration,
        }

        /// generates Snowflakes from a given EPOCH and machine id
        pub struct Snowcloud {
            epoch: SystemTime,
            machine_id: i64,
            counts: Arc<Mutex<Counts>>,
        }

        impl Clone for Snowcloud {
            fn clone(&self) -> Snowcloud {
                Snowcloud {
                    epoch: self.epoch.clone(),
                    machine_id: self.machine_id.clone(),
                    counts: Arc::clone(&self.counts),
                }
            }
        }

        impl Snowcloud {

            /// returns a new Snowcloud
            ///
            /// will return an error if the machine id is invalid, the
            /// timestamp is invalid, it failes to retrieve the current
            /// timestamp, or if the epoch is ahead of the current timestamp
            pub fn new(machine_id: i64, epoch: i64) -> error::Result<Snowcloud> {
                if machine_id < 0 || machine_id > MAX_MACHINE_ID {
                    return Err(error::Error::MachineIdInvalid);
                }

                if epoch < 0 || epoch > MAX_TIMESTAMP {
                    return Err(error::Error::EpochInvalid);
                }

                let Some(sys_time) = SystemTime::UNIX_EPOCH.clone()
                    .checked_add(Duration::from_millis(epoch as u64)) else {
                    return Err(error::Error::TimestampError);
                };
                let prev_time = sys_time.elapsed()?;

                Ok(Snowcloud {
                    epoch: sys_time,
                    machine_id,
                    counts: Arc::new(Mutex::new(Counts {
                        sequence: 1,
                        prev_time,
                    }))
                })
            }

            /// returns Snowcloud epoch
            pub fn get_epoch(&self) -> &SystemTime {
                &self.epoch
            }

            /// returns Snowcloud machine_id
            pub fn get_machine_id(&self) -> &i64 {
                &self.machine_id
            }

            /// retrieves the next available id
            ///
            /// if the current timestamp reaches max, the max sequence value is
            /// reached, or if it fails to get the current timestamp this will
            /// return an error.
            pub fn next_id(&self) -> error::Result<Snowflake> {
                let seq_value: i64;
                let now: Duration;

                {
                    // lock down counts for the current thread
                    let Ok(mut counts) = self.counts.lock() else {
                        return Err(error::Error::MutexError);
                    };

                    // since we do not know when the lock will be freed we
                    // have to get the time once the lock is freed to have
                    // an accurate timestamp
                    now = self.epoch.elapsed()?;

                    if now > MAX_DURATION {
                        return Err(error::Error::TimestampMaxReached);
                    }

                    let now_nanos = now.subsec_nanos();
                    let prev_millis = counts.prev_time.subsec_nanos() / 1_000_000;
                    let now_millis = now_nanos / 1_000_000;

                    // if we are still on the previously recorded millisecond
                    // then we increment the sequence. since the comparison of
                    // durations includes nanoseconds we have to do a little
                    // more work to only compare what we want
                    if counts.prev_time.as_secs() == now.as_secs() && prev_millis == now_millis {
                        seq_value = counts.sequence;

                        // before we increment, check to make sure that we
                        // have not reached the maximum sequence value. if
                        // we have then given an estimate to the next
                        // millisecond so that then user can decided on
                        // how to wait for the next available value
                        if seq_value > MAX_SEQUENCE {
                            return Err(error::Error::SequenceMaxReached(
                                Duration::from_nanos((1_000_000 - (now_nanos % 1_000_000)) as u64)
                            ));
                        }

                        // increment to the next sequence number
                        counts.sequence += 1;
                    } else {
                        // we are not on the previousely recorded millisecond
                        // so the sequence value will be set to one
                        seq_value = 1;

                        // set the previous time to now and prep for the next
                        // available sequence number
                        counts.prev_time = now.clone();
                        counts.sequence = 2;
                    }

                // counts_lock should be dropped and the mutext should now be
                // unlocked for the next 
                }

                Ok(Snowflake {
                    ts: now,
                    mid: self.machine_id,
                    seq: seq_value,
                })
            }
        }

        impl traits::IdGenerator for Snowcloud {
            type Error = error::Error;
            type Id = Snowflake;

            fn next_id(&self) -> std::result::Result<Self::Id, Self::Error> {
                Snowcloud::next_id(self)
            }
        }
    };
}

gen_code!(43, 8, 12);

/// spin loops for the next available id for a given number of attempts
///
/// if total attempts reaches 0 then the result will be none otherwise will be
/// some with whatever happened when generating the id
pub fn blocking_next_id<C>(cloud: &C, mut attempts: u8) -> Option<std::result::Result<C::Id, C::Error>> 
where
    C: traits::IdGenerator,
    C::Error: traits::NextAvailId
{
    use traits::NextAvailId;

    while attempts != 0 {
        match cloud.next_id() {
            Ok(sf) => {
                return Some(Ok(sf))
            },
            Err(err) => {
                let Some(dur) = err.next_avail_id() else {
                    return Some(Err(err));
                };

                let start = Instant::now();

                loop {
                    let Some(diff) = dur.checked_sub(start.elapsed()) else {
                        break;
                    };

                    let nanos = diff.subsec_nanos();

                    if nanos > 500_000 {
                        std::thread::sleep(diff);
                    } else if diff.subsec_nanos() > 1_000 {
                        std::thread::yield_now();
                    } else {
                        std::hint::spin_loop();
                    }
                }
            }
        }

        attempts -= 1;
    }

    None
}

#[cfg(test)]
mod test;
